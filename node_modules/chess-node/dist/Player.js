"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Pieces_1 = require("./Pieces");
const Tile_1 = __importDefault(require("./Tile"));
class Player {
    /**
     * @param {Boolean} isWhite determines if the player is white or black.
     * @param {String} playerName the name of the player.
     */
    constructor(isWhite = false, playerName = 'no_name') {
        this.ct = 0;
        this.playerName = playerName;
        this.rooks = new Array();
        this.pawns = new Array();
        this.knights = new Array();
        this.bishops = new Array();
        this.isWhite = isWhite;
        this.promotions = [];
        if (isWhite) {
            this.rooks.push(new Pieces_1.Rook(new Tile_1.default(1, 1), false, true));
            this.rooks.push(new Pieces_1.Rook(new Tile_1.default(8, 1), false, true));
            for (let i = 1; i <= 8; i++) {
                this.pawns.push(new Pieces_1.Pawn(new Tile_1.default(i, 2), false, true));
            }
            this.queen = new Pieces_1.Queen(new Tile_1.default(4, 1), false, true);
            this.bishops.push(new Pieces_1.Bishop(new Tile_1.default(3, 1), false, true));
            this.bishops.push(new Pieces_1.Bishop(new Tile_1.default(6, 1), false, true));
            this.king = new Pieces_1.King(new Tile_1.default(5, 1), false, true);
            this.knights.push(new Pieces_1.Knight(new Tile_1.default(2, 1), false, true));
            this.knights.push(new Pieces_1.Knight(new Tile_1.default(7, 1), false, true));
        }
        else {
            this.rooks.push(new Pieces_1.Rook(new Tile_1.default(1, 8)));
            this.rooks.push(new Pieces_1.Rook(new Tile_1.default(8, 8)));
            for (let i = 1; i <= 8; i++) {
                this.pawns.push(new Pieces_1.Pawn(new Tile_1.default(i, 7)));
            }
            this.queen = new Pieces_1.Queen(new Tile_1.default(4, 8));
            this.bishops.push(new Pieces_1.Bishop(new Tile_1.default(3, 8)));
            this.bishops.push(new Pieces_1.Bishop(new Tile_1.default(6, 8)));
            this.king = new Pieces_1.King(new Tile_1.default(5, 8));
            this.knights.push(new Pieces_1.Knight(new Tile_1.default(2, 8)));
            this.knights.push(new Pieces_1.Knight(new Tile_1.default(7, 8)));
        }
    }
    /**
     * Static method in turn of copy constructor.
     * @param {Player} player the peice to make a copy of.
     */
    static fromPlayer(player) {
        const isWhite = player.isWhite;
        const playerName = player.playerName;
        const rooks = new Array();
        for (const rook of player.rooks) {
            rooks.push(Pieces_1.Rook.fromRook(rook));
        }
        const promotions = [];
        for (const piece of player.promotions) {
            if (piece instanceof Pieces_1.Pawn) {
                promotions.push(Pieces_1.Pawn.fromPawn(piece));
            }
            else if (piece instanceof Pieces_1.Rook) {
                promotions.push(Pieces_1.Rook.fromRook(piece));
            }
            else if (piece instanceof Pieces_1.Bishop) {
                promotions.push(Pieces_1.Bishop.fromBishop(piece));
            }
            else if (piece instanceof Pieces_1.Knight) {
                promotions.push(Pieces_1.Knight.fromKnight(piece));
            }
            else if (piece instanceof Pieces_1.Queen) {
                promotions.push(Pieces_1.Queen.fromQueen(piece));
            }
        }
        const king = Pieces_1.King.fromKing(player.king);
        const queen = Pieces_1.Queen.fromQueen(player.queen);
        const bishops = new Array();
        for (const bishop of player.bishops) {
            bishops.push(Pieces_1.Bishop.fromBishop(bishop));
        }
        const knights = new Array();
        for (const knight of player.knights) {
            knights.push(Pieces_1.Knight.fromKnight(knight));
        }
        const pawns = new Array();
        for (const pawn of player.pawns) {
            pawns.push(Pieces_1.Pawn.fromPawn(pawn));
        }
        const ct = player.ct;
        const newPlayer = new this(isWhite, playerName);
        const playerExtra = {
            rooks: rooks,
            king: king,
            queen: queen,
            bishops: bishops,
            knights: knights,
            pawns: pawns,
            ct: ct,
            promotions: promotions
        };
        return Object.assign(newPlayer, playerExtra);
    }
    /**
     * Move a piece from one tile to another.
     * @param {Tile} currentTile the tile where the piece is at.
     * @param {Tile} newTile the tile where the pieuce is being moved to.
     * @param {Player} enemyPlayer the enemy player.
     * @param {Board} board the board the peice is playing on.
     * @returns {boolean} returns true if a piece was moved, returns false if the piece couldn't move
     */
    movePiece(currentTile, newTile, enemyPlayer, board) {
        const piece = this.getPieceByTile(currentTile);
        if (piece == null)
            return false;
        if (piece.isLegalMove(currentTile, newTile, this, enemyPlayer, board)) {
            const oldTile = piece.tile;
            piece.tile = newTile;
            piece.hasMoved = true;
            if (piece instanceof Pieces_1.Pawn && Math.abs(newTile.y - oldTile.y) == 2) {
                piece.enPassantEligable = true;
            }
            // disgusting ugly enPassant logic, I hate it... but it works. I'm sorry :(
            const enemyPiece = enemyPlayer.getPieceByTile(newTile);
            if (enemyPlayer.piecePresent(newTile) && enemyPiece) {
                enemyPiece.captured = true;
                this.ct = 0;
            }
            else if (piece instanceof Pieces_1.Pawn && Math.abs(newTile.x - oldTile.x) == 1) {
                if (this.isWhite) {
                    const enPassantTile = new Tile_1.default(newTile.x, newTile.y - 1);
                    if (enemyPlayer.piecePresent(enPassantTile)) {
                        const enPassantPiece = enemyPlayer.getPieceByTile(enPassantTile);
                        if (enPassantPiece instanceof Pieces_1.Pawn) {
                            enPassantPiece.captured = true;
                            this.ct = 0;
                        }
                        else {
                            this.ct++;
                        }
                    }
                    else {
                        this.ct++;
                    }
                }
                else {
                    const enPassantTile = new Tile_1.default(newTile.x, newTile.y + 1);
                    if (enemyPlayer.piecePresent(enPassantTile)) {
                        const enPassantPiece = enemyPlayer.getPieceByTile(enPassantTile);
                        if (enPassantPiece instanceof Pieces_1.Pawn) {
                            enPassantPiece.captured = true;
                            this.ct = 0;
                        }
                        else {
                            this.ct++;
                        }
                    }
                    else {
                        this.ct++;
                    }
                }
            }
            else {
                this.ct++;
            }
            this.removeEnpassant(enemyPlayer);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {Player} player
     */
    removeEnpassant(player) {
        for (const pawn of player.pawns) {
            pawn.enPassantEligable = false;
        }
    }
    /**
     * Find the peice at a current tile location
     * @param {Tile} tile the tile where the piece is being moved to.
     * @returns {Piece}
     */
    piecePresent(tile) {
        return this.getPieceByTile(tile) != null;
    }
    /**
     * Find the peice at a current tile location
     * @param {Tile} tile the tile where the piece is being moved to.
     * @returns {boolean}
     */
    getPieceByTile(tile) {
        // loop through each rook
        for (let i = 0; i < this.rooks.length; i++) {
            // if the rook is found at given tile, and it's not captured return the piece
            if (this.rooks[i].tile.equals(tile) && !this.rooks[i].captured) {
                return this.rooks[i];
            }
        }
        // loop through each pawn
        for (let i = 0; i < this.pawns.length; i++) {
            // if the pawn is found at given tile, and it's not captured return the piece
            if (this.pawns[i].tile.equals(tile) && !this.pawns[i].captured) {
                return this.pawns[i];
            }
        }
        // loop through each bishop
        for (let i = 0; i < this.bishops.length; i++) {
            // if the bishop is found at given tile, and it's not captured return the bishop
            if (this.bishops[i].tile.equals(tile) && !this.bishops[i].captured) {
                return this.bishops[i];
            }
        }
        // loop through each knight
        for (let i = 0; i < this.knights.length; i++) {
            // if the knight is found at given tile, and it's not captured return the piece
            if (this.knights[i].tile.equals(tile) && !this.knights[i].captured) {
                return this.knights[i];
            }
        }
        // if the queen is found at the current tile and it isn't captured return the queen.
        if (this.queen.tile.equals(tile) && !this.queen.captured) {
            return this.queen;
        }
        // if the queen is found at the current tile and it isn't captured return the queen.
        if (this.king.tile.equals(tile) && !this.king.captured) {
            return this.king;
        }
        // loop through each promotion
        for (let i = 0; i < this.promotions.length; i++) {
            if (this.promotions[i].tile.equals(tile) && !this.promotions[i].captured) {
                return this.promotions[i];
            }
        }
        // return null if there is not a piece found at the current location
        return null;
    }
}
exports.default = Player;
