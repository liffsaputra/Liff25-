"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Piece = void 0;
const Direction_1 = require("../Direction");
const Tile_1 = __importDefault(require("../Tile"));
class Piece {
    /**
     * @param {Tile} tile this this.tile of the piece.
     * @param {boolean} captured the captured status of the peice.
     * @param {boolean} isWhite is the piece white or black.
     * @param {boolean} hasMoves has the piece moved or not.
     */
    constructor(tile, captured = false, isWhite = false, hasMoved = false) {
        /**
         * Determine if a tiles peice is in the board
         * @param {Board} board the board of the peice
         */
        this.inBoard = (board) => !(this.tile.x > board.getSize() || this.tile.y > board.getSize() || this.tile.x < 1 || this.tile.y < 1);
        /**
         * @param {Direction} dir the direction to generate moves in
         * @param {Player} currentPlayer The player who's legal moves this function will return.
         * @param {Player} enemyPlayer this player is required to calculate legal moves for the currentPlayer
         * @param {Board} board the board that the two players exist in.
         * @return {Tile[]} returns an array of legal moves.
         */
        this.genMovesLin = (dir, currentPlayer, enemyPlayer, board) => {
            const moves = new Array();
            let limit;
            let yMultiplier;
            let xMultiplier;
            switch (dir) {
                case Direction_1.Direction.Down:
                    limit = board.getSize() - this.tile.y;
                    xMultiplier = 0;
                    yMultiplier = 1;
                    break;
                case Direction_1.Direction.Up:
                    limit = this.tile.y - 1;
                    xMultiplier = 0;
                    yMultiplier = -1;
                    break;
                case Direction_1.Direction.Right:
                    limit = board.getSize() - this.tile.x;
                    xMultiplier = 1;
                    yMultiplier = 0;
                    break;
                default:
                    limit = this.tile.x - 1;
                    xMultiplier = -1;
                    yMultiplier = 0;
            }
            for (let i = 1; i <= limit; i++) {
                const tempTile = new Tile_1.default(this.tile.x + i * xMultiplier, this.tile.y + i * yMultiplier);
                if (enemyPlayer.piecePresent(tempTile)) {
                    moves.push(tempTile);
                    break;
                }
                else if (currentPlayer.piecePresent(tempTile)) {
                    break;
                }
                else {
                    moves.push(tempTile);
                }
            }
            return moves;
        };
        /**
         * @param {DirectionAngle} dir the direction to generate moves in
         * @param {Player} currentPlayer The player who's legal moves this function will return.
         * @param {Player} enemyPlayer this player is required to calculate legal moves for the currentPlayer
         * @param {Board} board the board that the two players exist in.
         * @return {Array<Tile>} returns an array of legal moves.
         */
        this.genMovesAng = (dir, currentPlayer, enemyPlayer, board) => {
            const moves = new Array();
            const limit = board.getSize();
            let yMultiplier;
            let xMultiplier;
            switch (dir) {
                case Direction_1.DirectionAngle.UpRight:
                    xMultiplier = 1;
                    yMultiplier = 1;
                    break;
                case Direction_1.DirectionAngle.UpLeft:
                    xMultiplier = -1;
                    yMultiplier = 1;
                    break;
                case Direction_1.DirectionAngle.DownRight:
                    xMultiplier = 1;
                    yMultiplier = -1;
                    break;
                default:
                    xMultiplier = -1;
                    yMultiplier = -1;
            }
            for (let i = 1; i <= limit; i++) {
                const tempTile = new Tile_1.default(this.tile.x + i * xMultiplier, this.tile.y + i * yMultiplier);
                if (board.inBoard(tempTile)) {
                    if (enemyPlayer.piecePresent(tempTile)) {
                        moves.push(tempTile);
                        break;
                    }
                    else if (currentPlayer.piecePresent(tempTile)) {
                        break;
                    }
                    else {
                        moves.push(tempTile);
                    }
                }
            }
            return moves;
        };
        this.tile = tile;
        this.captured = captured;
        this.isWhite = isWhite;
        this.hasMoved = hasMoved;
    }
    /**
     * check to see if a move is infact a legal move.
     * @param {Player} currentPlayer
     * @param {Player} enemyPlayer
     * @param {Board} board
     * @param {Tile} oldtile
     * @param {Tile} tile
     */
    isLegalMove(oldtile, tile, currentPlayer, enemyPlayer, board) {
        if (board.inBoard(tile)) {
            const currPiece = currentPlayer.getPieceByTile(oldtile);
            let moves = new Array();
            if (currPiece != null) {
                moves = currPiece.generateMoves(currentPlayer, enemyPlayer, board);
                if (moves.length > 0) {
                    for (let i = 0; i < moves.length; i++) {
                        if (moves[i].equals(tile) && !currentPlayer.piecePresent(tile)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}
exports.Piece = Piece;
/**
 * Static method in turn of copy constructor.
 * @param {Piece} piece the peice to make a copy of.
 */
Piece.fromPiece = (piece) => new Piece(Tile_1.default.fromTile(piece.tile), piece.captured, piece.isWhite, piece.hasMoved);
