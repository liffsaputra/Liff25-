"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pawn = void 0;
const Piece_1 = require("./Piece");
const Tile_1 = __importDefault(require("../Tile"));
class Pawn extends Piece_1.Piece {
    /**
     * @param {Tile} tile this this.tile of the piece.
     * @param {boolean} captured the captured status of the peice.
     * @param {boolean} isWhite is the piece white or black.
     * @param {boolean} hasMoves has the piece moved or not.
     */
    constructor(tile, captured = false, isWhite = false, hasMoved = false, enPassant = false) {
        super(tile, captured, isWhite, hasMoved);
        this.enPassantEligable = enPassant;
    }
    /**
     * Generate an array of moves for a king.
     * @param {Player} currentPlayer The player who's legal moves this function will return.
     * @param {Player} enemyPlayer this player is required to calculate legal moves for the currentPlayer
     * @param {Board} board the board that the two players exist in.
     * @return {Array} returns an array of legal moves.
     */
    generateMoves(currentPlayer, enemyPlayer, board) {
        const position = this.tile;
        const moves = new Array();
        if (currentPlayer.isWhite) {
            if (!this.hasMoved && !enemyPlayer.piecePresent(new Tile_1.default(position.x, position.y + 2))) {
                moves.push(new Tile_1.default(position.x, position.y + 2));
            }
            if (!enemyPlayer.piecePresent(new Tile_1.default(position.x, position.y + 1))) {
                moves.push(new Tile_1.default(position.x, position.y + 1));
            }
            if (enemyPlayer.piecePresent(new Tile_1.default(position.x - 1, position.y + 1))) {
                moves.push(new Tile_1.default(position.x - 1, position.y + 1));
            }
            if (enemyPlayer.piecePresent(new Tile_1.default(position.x - 1, position.y))) {
                const ePiece = enemyPlayer.getPieceByTile(new Tile_1.default(position.x - 1, position.y));
                if (ePiece instanceof Pawn && ePiece.enPassantEligable) {
                    moves.push(new Tile_1.default(position.x - 1, position.y + 1));
                }
            }
            if (enemyPlayer.piecePresent(new Tile_1.default(position.x + 1, position.y + 1))) {
                moves.push(new Tile_1.default(position.x + 1, position.y + 1));
            }
            if (enemyPlayer.piecePresent(new Tile_1.default(position.x + 1, position.y))) {
                const ePiece = enemyPlayer.getPieceByTile(new Tile_1.default(position.x + 1, position.y));
                if (ePiece instanceof Pawn && ePiece.enPassantEligable) {
                    moves.push(new Tile_1.default(position.x + 1, position.y + 1));
                }
            }
        }
        else {
            if (!this.hasMoved && !enemyPlayer.piecePresent(new Tile_1.default(position.x, position.y - 2))) {
                moves.push(new Tile_1.default(position.x, position.y - 2));
            }
            if (!enemyPlayer.piecePresent(new Tile_1.default(position.x, position.y - 1))) {
                moves.push(new Tile_1.default(position.x, position.y - 1));
            }
            if (enemyPlayer.piecePresent(new Tile_1.default(position.x - 1, position.y - 1))) {
                moves.push(new Tile_1.default(position.x - 1, position.y - 1));
            }
            if (enemyPlayer.piecePresent(new Tile_1.default(position.x - 1, position.y))) {
                const ePiece = enemyPlayer.getPieceByTile(new Tile_1.default(position.x - 1, position.y));
                if (ePiece instanceof Pawn && ePiece.enPassantEligable) {
                    moves.push(new Tile_1.default(position.x - 1, position.y - 1));
                }
            }
            if (enemyPlayer.piecePresent(new Tile_1.default(position.x + 1, position.y - 1))) {
                moves.push(new Tile_1.default(position.x + 1, position.y - 1));
            }
            if (enemyPlayer.piecePresent(new Tile_1.default(position.x + 1, position.y))) {
                const ePiece = enemyPlayer.getPieceByTile(new Tile_1.default(position.x + 1, position.y));
                if (ePiece instanceof Pawn && ePiece.enPassantEligable) {
                    moves.push(new Tile_1.default(position.x + 1, position.y - 1));
                }
            }
        }
        for (let i = 0; i < moves.length; i++) {
            if (currentPlayer.piecePresent(moves[i]) || !board.inBoard(moves[i])) {
                moves.splice(i, 1);
                i--;
            }
        }
        return moves;
    }
}
exports.Pawn = Pawn;
/**
 * Static method in turn of copy constructor.
 * @param {Pawn} pawn the peice to make a copy of.
 */
Pawn.fromPawn = (pawn) => new Pawn(Tile_1.default.fromTile(pawn.tile), pawn.captured, pawn.isWhite, pawn.hasMoved, pawn.enPassantEligable);
