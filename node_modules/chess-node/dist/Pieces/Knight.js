"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Knight = void 0;
const Piece_1 = require("./Piece");
const Tile_1 = __importDefault(require("../Tile"));
class Knight extends Piece_1.Piece {
    /**
     * @param {Tile} tile this this.tile of the piece.
     * @param {boolean} captured the captured status of the peice.
     * @param {boolean} isWhite is the piece white or black.
     * @param {boolean} hasMoves has the piece moved or not.
     */
    constructor(tile, captured = false, isWhite = false, hasMoved = false) {
        super(tile, captured, isWhite, hasMoved);
        /**
         * Generate an array of moves for a Knight.
         * @abstract
         * @param {Player} currentPlayer The player who's legal moves this function will return.
         * @param {Player} enemyPlayer this player is required to calculate legal moves for the currentPlayer
         * @param {Board} board the board that the two players exist in.
         * @return {Array} returns an array of legal moves.
         */
        this.generateMoves = (currentPlayer, enemyPlayer, board) => {
            const moves = new Array();
            let tempTile = new Tile_1.default(this.tile.x + 1, this.tile.y + 2);
            if ((enemyPlayer.piecePresent(tempTile) || !currentPlayer.piecePresent(tempTile)) && board.inBoard(tempTile)) {
                moves.push(tempTile);
            }
            tempTile = new Tile_1.default(this.tile.x + 2, this.tile.y + 1);
            if ((enemyPlayer.piecePresent(tempTile) || !currentPlayer.piecePresent(tempTile)) && board.inBoard(tempTile)) {
                moves.push(tempTile);
            }
            tempTile = new Tile_1.default(this.tile.x - 2, this.tile.y + 1);
            if ((enemyPlayer.piecePresent(tempTile) || !currentPlayer.piecePresent(tempTile)) && board.inBoard(tempTile)) {
                moves.push(tempTile);
            }
            tempTile = new Tile_1.default(this.tile.x - 1, this.tile.y + 2);
            if ((enemyPlayer.piecePresent(tempTile) || !currentPlayer.piecePresent(tempTile)) && board.inBoard(tempTile)) {
                moves.push(tempTile);
            }
            tempTile = new Tile_1.default(this.tile.x - 1, this.tile.y - 2);
            if ((enemyPlayer.piecePresent(tempTile) || !currentPlayer.piecePresent(tempTile)) && board.inBoard(tempTile)) {
                moves.push(tempTile);
            }
            tempTile = new Tile_1.default(this.tile.x - 2, this.tile.y - 1);
            if ((enemyPlayer.piecePresent(tempTile) || !currentPlayer.piecePresent(tempTile)) && board.inBoard(tempTile)) {
                moves.push(tempTile);
            }
            tempTile = new Tile_1.default(this.tile.x + 1, this.tile.y - 2);
            if ((enemyPlayer.piecePresent(tempTile) || !currentPlayer.piecePresent(tempTile)) && board.inBoard(tempTile)) {
                moves.push(tempTile);
            }
            tempTile = new Tile_1.default(this.tile.x + 2, this.tile.y - 1);
            if ((enemyPlayer.piecePresent(tempTile) || !currentPlayer.piecePresent(tempTile)) && board.inBoard(tempTile)) {
                moves.push(tempTile);
            }
            return moves;
        };
    }
}
exports.Knight = Knight;
Knight.fromKnight = (knight) => new Knight(Tile_1.default.fromTile(knight.tile), knight.captured, knight.isWhite, knight.hasMoved);
