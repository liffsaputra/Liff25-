"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bishop = void 0;
const Piece_1 = require("./Piece");
const Tile_1 = __importDefault(require("../Tile"));
const Direction_1 = require("../Direction");
class Bishop extends Piece_1.Piece {
    /**
     * @param {Tile} tile this this.tile of the piece.
     * @param {boolean} captured the captured status of the peice.
     * @param {boolean} isWhite is the piece white or black.
     * @param {boolean} hasMoves has the piece moved or not.
     */
    constructor(tile, captured = false, isWhite = false, hasMoved = false) {
        super(tile, captured, isWhite, hasMoved);
        /**
         * @param {Player} currentPlayer The player who's legal moves this function will return.
         * @param {Player} enemyPlayer this player is required to calculate legal moves for the currentPlayer
         * @param {Board} board the board that the two players exist in.
         * @return {Array<Tile>} returns an array of legal moves.
         */
        this.generateMoves = (currentPlayer, enemyPlayer, board) => {
            const upRight = this.genMovesAng(Direction_1.DirectionAngle.UpRight, currentPlayer, enemyPlayer, board);
            const upLeft = this.genMovesAng(Direction_1.DirectionAngle.UpLeft, currentPlayer, enemyPlayer, board);
            const downRight = this.genMovesAng(Direction_1.DirectionAngle.DownRight, currentPlayer, enemyPlayer, board);
            const downLeft = this.genMovesAng(Direction_1.DirectionAngle.DownLeft, currentPlayer, enemyPlayer, board);
            return upRight.concat(upLeft, downLeft, downRight);
        };
    }
}
exports.Bishop = Bishop;
Bishop.fromBishop = (bishop) => new Bishop(Tile_1.default.fromTile(bishop.tile), bishop.captured, bishop.isWhite, bishop.hasMoved);
