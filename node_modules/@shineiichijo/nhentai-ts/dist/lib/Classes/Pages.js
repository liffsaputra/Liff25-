"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Pages_title;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pages = void 0;
const pdfkit_1 = __importDefault(require("pdfkit"));
const os_1 = require("os");
const promises_1 = require("fs/promises");
const fs_1 = require("fs");
const axios_1 = __importDefault(require("axios"));
const jszip_1 = __importDefault(require("jszip"));
const path_1 = require("path");
class Pages {
    /**
     *
     * @param pages An array of URLS of the doujin pages
     */
    constructor(pages, __title) {
        this.pages = pages;
        _Pages_title.set(this, void 0);
        __classPrivateFieldSet(this, _Pages_title, __title, "f");
    }
    PDF(filename) {
        return __awaiter(this, void 0, void 0, function* () {
            const pdf = new pdfkit_1.default({ autoFirstPage: false });
            const file = filename
                ? `${filename}${filename.endsWith('.pdf') ? '' : '.pdf'}`
                : `${(0, os_1.tmpdir)()}/${Math.random().toString(36)}.pdf`;
            const stream = (0, fs_1.createWriteStream)(file);
            pdf.pipe(stream);
            for (const url of this.pages) {
                const { data } = yield axios_1.default.get(url, {
                    responseType: 'arraybuffer'
                });
                const img = pdf.openImage(data);
                pdf.addPage({ size: [img.width, img.height] });
                pdf.image(img, 0, 0);
                const index = this.pages.indexOf(url);
                if (index === this.pages.length - 1)
                    pdf.end();
            }
            yield new Promise((resolve, reject) => {
                stream.on('finish', () => resolve(file));
                stream.on('error', reject);
            });
            if (filename)
                return file;
            const buffer = yield (0, promises_1.readFile)(file);
            yield (0, promises_1.unlink)(file);
            return buffer;
        });
    }
    zip(filename) {
        return __awaiter(this, void 0, void 0, function* () {
            const zip = new jszip_1.default();
            const folder = zip.folder(__classPrivateFieldGet(this, _Pages_title, "f"));
            for (const url of this.pages)
                folder.file(`${this.pages.indexOf(url) + 1}.${url.split('.')[url.split('.').length - 1]}`, (yield axios_1.default.get(url, { responseType: 'arraybuffer' }))
                    .data, { binary: true });
            const buffer = yield zip.generateAsync({ type: 'nodebuffer' });
            if (filename) {
                yield (0, promises_1.writeFile)(`${filename}${filename.endsWith('.zip') ? '' : '.zip'}`, buffer);
                return `${filename}${filename.endsWith('.zip') ? '' : '.zip'}`;
            }
            return buffer;
        });
    }
    /**
     * Downloads the pages of a doujin and saves all of it in a folder
     * @param folderName The name of the folder in which all of the pages should be saved
     */
    download(folderName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!folderName)
                throw new Error('No folder name provided to save the downloaded doujin pages');
            if (!(0, fs_1.existsSync)(folderName))
                yield (0, promises_1.mkdir)(folderName, { recursive: true });
            const isDirectory = (yield (0, promises_1.stat)(folderName)).isDirectory();
            if (!isDirectory)
                throw new Error('Expected a directory for saving the downloads, but recieved a file.');
            for (const url of this.pages)
                yield (0, promises_1.writeFile)((0, path_1.join)(folderName, `${this.pages.indexOf(url) + 1}.${url.split('.')[url.split('.').length - 1]}`), (yield axios_1.default.get(url, {
                    responseType: 'arraybuffer'
                })).data);
        });
    }
}
exports.Pages = Pages;
_Pages_title = new WeakMap();
